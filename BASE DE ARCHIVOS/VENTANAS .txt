
# ─── CONFIGURACIONES PDF ──────────────────────────────
MARGEN_IZQ     = 20
MARGEN_SUP     = 60
ESPACIO_X      = 65
ESPACIO_Y      = 120
COLUMNAS       = 2
FILAS          = 4

SIZE_NUM       = 20
SIZE_INFO      = 13
REINTEGRO_W    = 50
REINTEGRO_H    = 50

DELTA_Y_FILA_3 = 2
DELTA_Y_FILA_4 = 5

SERIE_MAP = {
    "Srs_ib1.xlsx":    "V",
    "Srs_ib2.xlsx":    "+",
    "Srs_ib3.xlsx":    "&",
    "Srs_Manila.xlsx": "M"
}

per_cell_offsets = {
    0: {"grid_x":-15,"grid_y":  30, "info_x": -20, "info_y":  25, "tel_x": 165, "tel_y":  25, "rein_x": 190, "rein_y":  25},
    1: {"grid_x":-55, "grid_y":  30, "info_x":-70, "info_y":  25, "tel_x":125,"tel_y":  25, "rein_x": 150, "rein_y":  25},
    2: {"grid_x": -15, "grid_y":  90, "info_x": -20, "info_y":  85, "tel_x": 165, "tel_y":  85, "rein_x": 190, "rein_y": -25},
    3: {"grid_x":-55, "grid_y":  90, "info_x": -70, "info_y":  85, "tel_x": 125, "tel_y":  85, "rein_x": 150, "rein_y": -30},
    4: {"grid_x":-15, "grid_y": 150, "info_x":  -20, "info_y": 145, "tel_x": 165, "tel_y": 145, "rein_x": 190, "rein_y": -85},
    5: {"grid_x": -55, "grid_y": 150, "info_x": -70, "info_y": 145, "tel_x": 125, "tel_y": 145, "rein_x": 150, "rein_y": -85},
    6: {"grid_x":-15, "grid_y": 210, "info_x":  -20, "info_y": 205, "tel_x": 165, "tel_y": 205, "rein_x": 190, "rein_y": -150},
    7: {"grid_x": -55, "grid_y": 210, "info_x": -70, "info_y": 205, "tel_x": 125, "tel_y": 205, "rein_x": 155, "rein_y": -150},
}

# ─── RUTA IMPRESIÓN (BOLETOS Y PLANILLA) ──────────────
@app.route('/impresion', methods=['GET', 'POST'])
def impresion():
    files      = sorted(f for f in os.listdir(DATA_DIR) if f.lower().endswith(('.xlsx', '.csv')))
    series     = [(f, SERIE_MAP.get(f, f)) for f in files]
    reintegros = sorted(f for f in os.listdir(REINTEGROS_DIR) if f.lower().endswith('.png'))
    fecha_hoy  = date.today().strftime('%Y-%m-%d')

    if request.method == 'POST':
        form_type = request.form.get('form_type')

        # ── BOLETOS ───────────────────────
        if form_type == 'boletos':
            nombre     = request.form['serie_archivo']
            start      = request.form.get('serie_inicio', '')
            end        = request.form.get('serie_fin', '')
            valor      = request.form['valor']
            telefono   = request.form['telefono']
            fecha_str  = request.form.get('fecha_sorteo', fecha_hoy)
            rein_esp   = request.form.get('reintegro_especial', '')
            cnt_esp    = int(request.form.get('cant_reintegro_especial', 0))
            incA       = (request.form.get('incluir_aleatorio', '1') == '1')

            path = os.path.join(DATA_DIR, nombre)
            if nombre.lower().endswith('.csv'):
                df = pd.read_csv(path, dtype=str).fillna('')
            else:
                df = pd.read_excel(path, dtype=str).fillna('')
            all_ids = df[df.columns[0]].astype(str).tolist()

            try:
                s_idx = all_ids.index(start) if start else 0
            except ValueError:
                flash(f'Boleto inicial “{start}” no existe.', 'danger')
                return redirect(url_for('impresion'))
            try:
                e_idx = all_ids.index(end) + 1 if end else len(all_ids)
            except ValueError:
                flash(f'Boleto final “{end}” no existe.', 'danger')
                return redirect(url_for('impresion'))

            ids       = all_ids[s_idx:e_idx]
            registros = df[df[df.columns[0]].astype(str).isin(ids)].to_dict('records')

            buf_b = generar_pdf_boletos_excel(
                ids, registros, valor, telefono,
                nombre, rein_esp, cnt_esp,
                reintegros, incA, fecha_str
            )
            return send_file(buf_b, download_name='boletos_bingo.pdf', as_attachment=True)

        # ── PLANILLA ───────────────────────
        elif form_type == 'planilla':
            archivo = request.form['serie_archivo']
            inicio  = int(request.form['planilla_inicio'])
            fin     = int(request.form['planilla_fin'])
            fecha_p = request.form.get('planilla_fecha', fecha_hoy)

            path = os.path.join(DATA_DIR, archivo)
            if archivo.lower().endswith('.csv'):
                df2 = pd.read_csv(path, dtype=str).fillna('')
            else:
                df2 = pd.read_excel(path, dtype=str).fillna('')
            all_ids = df2[df2.columns[0]].astype(str).tolist()
            ids_p   = all_ids[inicio-1:fin]

            buf = generar_pdf_planilla(
                ids_p, archivo, session.get('usuario','ADMIN'),
                fecha_p, inicio, fin, SERIE_MAP
            )
            return send_file(buf, download_name=f'planilla_{inicio}_a_{fin}.pdf', as_attachment=True)

    # ─ GET / formulario ─────────────
    return render_template(
        'impresion_boletos_excel.html',
        series=series,
        reintegros=reintegros,
        fecha_hoy=fecha_hoy,
        usuario=session.get('usuario', 'admin'),
        rol=session.get('rol', 'admin'),
        avatar=session.get('avatar', ''),
        permisos=session.get('permisos', [])
    )

# ─── FUNCIÓN PARA GENERAR PDF DE BOLETOS ─────────────
def generar_pdf_boletos_excel(
    ids, registros, valor, telefono,
    nombre, rein_esp, cnt_esp,
    reintegros, incA, fecha_sorteo
):
    buf = BytesIO()
    c   = canvas.Canvas(buf, pagesize=A4)
    ancho, alto = A4
    N = len(registros)

    esp_idx = random.sample(range(N), min(N, cnt_esp)) if rein_esp else []
    ale_idx = [i for i in range(N) if i not in esp_idx] if incA else []

    for start in range(0, N, FILAS*COLUMNAS):
        page = registros[start:start+FILAS*COLUMNAS]
        for i, row in enumerate(page):
            pos = start + i
            col = i % COLUMNAS
            fil = i // COLUMNAS

            ancho_b = (ancho + 2*MARGEN_IZQ - ESPACIO_X*(COLUMNAS-1)) / COLUMNAS
            alto_b  = (alto  + 2*MARGEN_SUP - ESPACIO_Y*(FILAS-1))   / FILAS
            x0 = MARGEN_IZQ + col*(ancho_b + ESPACIO_X)
            y0 = alto - MARGEN_SUP - fil*(alto_b + ESPACIO_Y)
            if fil == 2: y0 -= DELTA_Y_FILA_3
            if fil == 3: y0 -= DELTA_Y_FILA_4

            size = min(ancho_b, alto_b) / 5
            offs = per_cell_offsets[i]

            # — Rejilla 5×5 + QR en N3 —
            bx0 = x0 + offs['grid_x']
            by0 = y0 + offs['grid_y']
            c.setFont('Helvetica-Bold', SIZE_NUM)
            for r in range(5):
                for j, letra in enumerate('bingo'):
                    cx = bx0 + j*size
                    cy = by0 - r*size
                    if letra=='n' and r==2:
                        qr = qrcode.make(f"{ids[pos]}|{fecha_sorteo}")
                        buf_qr = BytesIO(); qr.save(buf_qr,'PNG'); buf_qr.seek(0)
                        c.drawImage(ImageReader(buf_qr), cx+2, cy+2, size-4, size-4)
                    else:
                        v = str(row.get(f"{letra}{r+1}", "-"))
                        c.drawCentredString(cx+size/2, cy+size*0.28, v)

            # — Serie, fecha, valor —
            info = f"{ids[pos]}{SERIE_MAP.get(nombre,nombre)} | {fecha_sorteo} | ${valor}"
            c.setFont('Helvetica', SIZE_INFO)
            c.drawString(
                x0 + offs['info_x'],
                y0 - size*5 + offs['info_y'],
                info
            )

            # — Teléfono separado —
            tel = f"Tel: {telefono}"
            c.setFont('Helvetica', SIZE_INFO)
            c.drawString(
                x0 + offs['tel_x'],
                y0 - size*5 + offs['tel_y'],
                tel
            )

            # — Icono de reintegro —
            img_file = None
            if pos in esp_idx and rein_esp:
                img_file = rein_esp
            elif pos in ale_idx and reintegros:
                otros = [r for r in reintegros if r != rein_esp]
                img_file = random.choice(otros) if otros else None

            if img_file:
                c.drawImage(
                    ImageReader(os.path.join(REINTEGROS_DIR, img_file)),
                    x0 + offs['rein_x'], y0 - offs['rein_y'],
                    REINTEGRO_W, REINTEGRO_H,
                    mask='auto'
                )

        c.showPage()
    c.save()
    buf.seek(0)
    return buf


def generar_pdf_planilla(ids, serie_archivo, vendedor, fecha, inicio, fin, serie_map, num_planilla=None):
    from io import BytesIO
    from datetime import datetime
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4, landscape
    from reportlab.lib.utils import ImageReader
    from reportlab.platypus import Table, TableStyle
    from reportlab.lib import colors
    import os, qrcode

    # — Formatear fecha en español —
    dt = datetime.strptime(fecha, "%Y-%m-%d")
    dias   = ["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado","Domingo"]
    meses  = {
        1:"Enero",2:"Febrero",3:"Marzo",4:"Abril",
        5:"Mayo",6:"Junio",7:"Julio",8:"Agosto",
        9:"Septiembre",10:"Octubre",11:"Noviembre",12:"Diciembre"
    }
    formatted_date = f"{dias[dt.weekday()]}, {dt.day} de {meses[dt.month]} del {dt.year}"
    fecha_limpia   = dt.strftime("%Y%m%d")
    serie_letra    = serie_map.get(serie_archivo, "")

    # — Rangos —
    left_desde  = inicio
    left_hasta  = min(inicio + 19, fin)
    right_desde = inicio + 20
    right_hasta = min(inicio + 39, fin)
    full_desde  = inicio
    full_hasta  = min(inicio + 39, fin)

    # — Generadores de cadena QR —
    def qr_cadena(tipo, desde, hasta, serie):
        return f"SORTEO{fecha_limpia}{tipo}A{desde}A{hasta}{serie}"

    # — Preparar canvas —
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=landscape(A4))
    ancho, alto = landscape(A4)

    # — Márgenes y constantes —
    M_LEFT, M_RIGHT, M_BOTTOM = 20, 20, 20
    GUTTER, HEADER_H, QR_SIZE = 20, 60, 40

    # — Área útil para tablas —
    HALF_W  = (ancho - M_LEFT - M_RIGHT - GUTTER) / 2
    TOP_Y   = alto - HEADER_H - 5
    BOT_Y   = M_BOTTOM
    AVAIL_H = TOP_Y - BOT_Y

    # — Filas y altura dinámica —
    NUM_ROWS = 21
    ROW_H    = AVAIL_H / NUM_ROWS

    # — Posiciones X y ancho de tabla —
    X_L, X_R = M_LEFT, M_LEFT + HALF_W + GUTTER
    TABLE_W  = HALF_W - 20
    PAD      = 10

    # — Recursos y fuentes —
    LOGO_PATH = os.path.join("static","golpe_suerte_logo.png")
    FB, FR    = "Helvetica-Bold", "Helvetica"

    # — Índices de planilla según rango —
    left_index  = (left_desde - 1) // 20 + 1
    right_index = (right_desde - 1) // 20 + 1

    # — Función: dibuja header en x0 con QR de su rango —
    def draw_header(x0, sheet_num, tipo, desde, hasta):
        # fondo gris
        c.setFillColorRGB(0.9,0.9,0.9)
        c.rect(x0, alto - HEADER_H, HALF_W, HEADER_H, fill=1, stroke=0)
        c.setFillColor(colors.black)

        # logo grande manteniendo proporción
        img = ImageReader(LOGO_PATH)
        ow, oh = img.getSize()
        dh = HEADER_H - 4
        dw = dh * ow / oh
        c.drawImage(img,
                    x0 + 8,
                    alto - HEADER_H + 2,
                    width=dw, height=dh,
                    mask="auto")

        # recuadros de fecha
        box_w = HALF_W * 0.45
        box_h = 20
        bx = x0 + (HALF_W - box_w) / 2
        by = alto - HEADER_H + 8
        c.setLineWidth(1.5)
        c.setFillColor(colors.white)
        c.roundRect(bx, by + box_h + 4, box_w, box_h, 4, stroke=1, fill=1)  # vacío arriba
        c.roundRect(bx, by,               box_w, box_h, 4, stroke=1, fill=1)  # fecha
        c.setFillColor(colors.black)
        c.setFont(FB, 10)
        c.drawCentredString(bx + box_w/2, by + box_h/2 - 4, formatted_date)

        # QR de rango para esta mitad
        data_qr = qr_cadena(tipo, desde, hasta, serie_letra)
        buf = BytesIO(); qrcode.make(data_qr).save(buf,format="PNG"); buf.seek(0)
        qx = x0 + HALF_W - QR_SIZE - 8
        qy = alto - HEADER_H + 8
        c.drawImage(ImageReader(buf), qx, qy, QR_SIZE, QR_SIZE)

        # recuadro del número a la izquierda del QR
        pn_w, pn_h = 36, 28
        px = qx - pn_w - 6
        py = qy + (QR_SIZE - pn_h)/2
        c.setFillColor(colors.white)
        c.setLineWidth(1.5)
        c.roundRect(px, py, pn_w, pn_h, 4, stroke=1, fill=1)
        c.setFillColor(colors.black)
        c.setFont(FB, 18)
        c.drawCentredString(px + pn_w/2, py + pn_h/2 - 5, str(sheet_num))

    # — Dibujar headers izquierdo y derecho con sus propios QR —
    draw_header(X_L, left_index,  "L1", left_desde,  left_hasta)
    draw_header(X_R, right_index, "L2", right_desde, right_hasta)

    # — Línea divisoria central —
    c.setLineWidth(2)
    c.line(X_R, TOP_Y, X_R, BOT_Y)

    # — QR central de rango completo (40 boletos) —
    data_full = qr_cadena("RG", full_desde, full_hasta, serie_letra)
    buf2 = BytesIO(); qrcode.make(data_full).save(buf2,format="PNG"); buf2.seek(0)
    mid_y = BOT_Y + (AVAIL_H/2) - (QR_SIZE/2)
    c.drawImage(ImageReader(buf2),
                ancho/2 - QR_SIZE/2,
                mid_y,
                QR_SIZE, QR_SIZE)

    # — Construir siempre 21 filas por tabla —
    left_data = [["Boleto / Nombres Apellidos",""]]
    for i in range(20):
        n = inicio + i
        left_data.append([str(n) if n <= fin else "", ""])
    right_data = [["Boleto / Nombres Apellidos",""]]
    for i in range(20):
        n = inicio + 20 + i
        right_data.append([str(n) if n <= fin else "", ""])

    # — Recuadro en encabezado de tabla —
    header_y = TOP_Y - ROW_H
    c.setLineWidth(1.5)
    c.roundRect(X_L + PAD, header_y, TABLE_W, ROW_H, 4, stroke=1, fill=0)
    c.roundRect(X_R + PAD, header_y, TABLE_W, ROW_H, 4, stroke=1, fill=0)

    # — Estilo de tabla —
    from reportlab.platypus import Table
    style = TableStyle([
        ("SPAN",        (0,0),(1,0)),
        ("FONT",        (0,0),(1,0), FB, 10),
        ("ALIGN",       (0,0),(1,0),"CENTER"),
        ("FONT",        (0,1),(0,-1), FB, 12),
        ("FONT",        (1,1),(1,-1), FR, 8),
        ("VALIGN",      (0,0),(-1,-1),"MIDDLE"),
        ("INNERGRID",   (0,0),(-1,-1),1,colors.black),
        ("BOX",         (0,0),(-1,-1),2,colors.black),
        ("LEFTPADDING", (0,0),(-1,-1),3),
        ("RIGHTPADDING",(0,0),(-1,-1),3),
    ])

    # — Renderizar tablas —
    tblL = Table(left_data,  colWidths=[40, TABLE_W-40], rowHeights=[ROW_H]*NUM_ROWS)
    tblL.setStyle(style); tblL.wrapOn(c,0,0); tblL.drawOn(c, X_L+PAD, BOT_Y)
    tblR = Table(right_data, colWidths=[40, TABLE_W-40], rowHeights=[ROW_H]*NUM_ROWS)
    tblR.setStyle(style); tblR.wrapOn(c,0,0); tblR.drawOn(c, X_R+PAD, BOT_Y)

    c.save()
    buffer.seek(0)
    return buffer

